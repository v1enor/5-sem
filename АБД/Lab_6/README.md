# LAB 6

- **Гранула**
    
    Память различным пулам в SGA выделяется **блоками**, которые называются гранулами
    
    Одна гранула (granule) - это **область памяти** размером 4, 8 или 16 Мбайт 
    
    Гранула является **наименьшей единицей выделения памяти**
    
    **Гранулы** - 
    
    - Область сортировки для функций, таких как ORDER BY и GROUP BY
    - Область хеша для выполнения соединения таблиц
    - Область создания битового массива
    - Область слияния битовых массивов, используемую для того, чтобы разрешать план выполнения индекса битового массива

**Буферный пул** (буферный кэш) – область SGA, которая содержит образы блоков, считанные из файлов данных или созданные динамически, чтобы реализовать модель согласованного чтения
Совместно используется всеми пользователями

1. **Расшифруйте аббревиатуру SGA. Перечислите основные пулы памяти SGA, поясните их назначение.**
    
    SGA - Системная Глобальная область или область разделяемой памяти 
    Назначение SGA состоят в ускорении производительности запросов и
    обеспечении большого объема параллельной активности. Поскольку
    обработка в памяти намного быстрее дискового ввода-вывода, размер SGA – один из важнейших конфигурационных параметров при настройке базы данных на достижение оптимальной производительности. Когда вы
    запускаете экземпляр Oracle, он занимает определенный объем памяти из оперативной памяти операционной системы и этот объем определяется компонентом SGA в инициализационном файле. Когда экземпляр останавливается, память, использованная SGA, возвращается операционной системе.
    SGA – наиболее важный компонент памяти в экземпляре Oracle.
    • **Буферный кэш базы данных.** Хранит копии блоков данных, прочитанных из файлов данных.
    • **Разделенный пул.** Содержит библиотечный кэш для хранения,
    разобранного SQL и PL/SQL кода, готового к использованию всеми
    пользователями. Он также содержит кэш словаря данных, который хранит всю информацию словаря.
    • **Буфер журнала повторного выполнения.** Содержит информацию,
    необходимую для восстановления изменений, проведенных в базе данных
    операциями DML (языка манипулирования данными). Эта информация затем
    записывается в журналы повторного выполнения писателем журналов.
    • **Пул Java.** Представляет пространство «кучи» для создания
    объектов Java.
    • **Большой пул.** Хранит крупные выделения памяти, такие как
    резервные буферы RMAN.
    • **Пул потоков.** Поддерживает средство Oracle Streams (средство для
    репликации данных между базами данных). Oracle Streams – это технология, которая позволяет разделять общие данные между разными базами данных и между разными средами приложений. Пул Stream – это память, выделенная для поддержки деятельности Streams в вашем экземпляре
    
    **PGA** - области памяти, которые содержат данные и управляющую информацию для серверного или фонового процесса, такие как пространство стека или информация сеанса.
    
    Это область памяти выделенного серверного процесса. Другие процессы не имеют доступа к ней.
    
    - доступ к PGA является монопольным для серверного процесса
    - у каждого серверного процесса и фонового процесса есть собственная PGA
    - запись в PGA выполняется только кодом Oracle, действующим по запросу PGA
    - содержит стековое пространство
    - содержит пользовательскую глобальную область (UGA)
    
    **UGA *User Global Area***
    
    это память, связанная с сеансом пользователя. 
    
    - Область курсоров
    - Область хранения данных сеанса
    - Рабочие области SQL:
        - Область сортировки для функций, таких как ORDER BY и GROUP BY
        - Область хеша для выполнения соединения таблиц
        - Область создания битового массива
        - Область слияния битовых массивов, используемую для того, чтобы разрешать план выполнения индекса битового массива
    - Располагается в области SGA, если подключение выполнено  посредством разделяемого сервера, в PGA остается только стековое пространство
    - Располагается в области PGA, если подключение выполнено  через выделенный сервер
2. **Поясните параметры SGA_MAX_SIZE и SGA_TARGET.**
    
    SGA_MAX_SIZE – максимальный размер памяти SGA.
    SGA_TARGET – текущий (возможный) размер памяти SGA.
    
3. **Поясните назначение буферного кэша инстанса. Поясните назначение пулов КЕЕP, DEFAULT и RECYCLE буферного кэша.**
    
    Буферный кэш состоит из буферов памяти, в которых хранятся данные, прочитанные из файлов на диске. Из буферного кэша гораздо быстрее обращаться к данным, чем из диска. Т.к. при изменениях со стороны клиента изменения идут в буферный кэш, то здесь содержатся как скопированная с диска информация, так и измененная инфа, которая подлежит записи на диск. Чем больше буферный кэш, тем меньше обращений к диску будет, и производительность повысится.
    Причем будет обрыганством выделять всем объектам БД один и тот же буферный кэш. К какой то таблице обращаются тысячу раз в день, а к другой – два раза в день. Для этого буферный кэш разделен на три пула: KEEP, DEFAULT и RECYCLE.
    **KEEP** – постоянный пул – постоянно хранит блоки данных в памяти. Например, для небольших таблиц, к которым постоянно идет обращение.
    **RECYCLE** – повторно используемый пул – удаляет блоки данных из кэша сразу же после использования. Следует использовать осторожно; Например, для большой таблицы, к которой нечасто обращаются.
    **DEFAULT** – стандартный пул – назначается по умолчанию
    
    | Буферный пул | Инициализационный параметр | Описание |
    | --- | --- | --- |
    | Постоянный буферный пул(keep buffer pool) | DB_KEEP_CACHE_SIZE | Постоянно хранит блоки данных в памяти. У вас могут быть маленькие таблицы, к которым выполняются частые обращения, и для предотвращения их удаления из буферного кэша им можно назначить постоянный буферный пул при создании таблицы. |
    | Повторно используемый буферный пул(recycle buffer pool) | DB_RECYCLE_CACHE_SIZE | Удаляет данные из кэша немедленно после использования. Этот буферный пул следует применять осторожно, если вы вообще решите использовать его. Повторно используемый буферный пул удаляет объект из кэша сразу по завершении транзакции. Очевидно, что его следует применять только для крупных таблиц, обращение к которым осуществляется нечасто, и которые не нужно хранить к кэше неопределенно долго. |
    | Буферный пул по умолчанию(default buffer pool) | DB_CACHE_SIZE | Содержит все данные и объекты, которые не назначены в постоянный и повторно используемый буферные пулы. |
4. **Поясните принцип вытеснения блоков буферного кэша (LRU).**
    
    Буферы в кэше организованы в два списка: список записи и список наименее недавно использованных (LRU). Список **записи** содержит грязные буферы*,* которые содержат данные, которые были изменены, но еще не были записаны на диск. Список **LRU** содержит свободные буферы, закрепленные буферы и грязные буферы, которые еще не были перемещены в список записи. **Свободные буферы** не содержат никаких полезных данных и доступны для использования. В настоящее время осуществляется доступ к закрепленным буферам.
    
    В первый раз, когда пользовательскому процессу Oracle требуется определенный фрагмент данных, он выполняет поиск данных в буферном кэше базы данных. Если процесс находит данные уже в кэше (**попадание** в кэш), он может считывать данные непосредственно из памяти. Если процесс не может найти данные в кэше (**промах** кэша), он должен скопировать блок данных из файла данных на диске в буфер в кэше, прежде чем обращаться к данным. Доступ к данным через попадание в кэш происходит быстрее, чем доступ к данным через промах кэша.
    
    **Least recently used** (LRU): в первую очередь, вытесняется неиспользованный дольше всех. Этот алгоритм требует отслеживания того, что и когда использовалось, что может оказаться довольно накладно, особенно если нужно проводить дополнительную проверку, чтобы в этом убедиться. Общая реализация этого метода требует сохранения «бита возраста» для строк кэша и за счет этого происходит отслеживание наименее использованных строк (то есть за счет сравнения таких битов).
    
    ***ИЛИ***
    
    Буферы памяти в буферном кэше делятся на три группы:
    
    1. Свободные буферы – не содержат данных, сюда можно данные записать
    2. Грязные буферы – данные, которые были прочитаны с диска и потом модифицированы, и они еще не записаны в файл
    3. Занятые буферы – данные, активно используемые в активном сеансе
    
    Для всех этих буферов поддерживает алгоритм LRU – Least Recently Used. Он используется для того, чтобы понять, какие именно грязные блоки надо сейчас записать на диск. Если записывать грязные неиспользуемые блоки на диск, то производительность повышается.
    
    Запись грязных блоков на диск идет в следующих случаях:
    
    - через 3 секунды тайм-аута
    - на контрольной точке
    - превышение лимита грязных блоков
    - процесс не может найти свободный блок
5. **Поясните принцип вытеснения блоков таблицы, созданной оператором CREATE TABLE … CACHE.**
    
    Таблицы, помеченные ключевым словом cache, отправлятся в конец LRU-списка.
    Для небольших таблиц обычно размещение идёт в DEFAULT пул.
    
    ***ИЛИ***
    
    CACHE – помещение таблицы в конец LRU-списка (для малых таблиц) обычно в
    default pool
    Если вы последовательно выполните один и тот же запрос два или более
    раз, вы обратите внимание, что второй (и последующие) запросы выполняются
    быстрее, чем первый. Дело в том, что начальный запрос перемещает данные
    таблицы в буфера данных в памяти, где они остаются, пока не будут
    вытолкнуты другими данными из других таблиц, используемых для ответа на
    другие запросы. Чтобы сохранить конкретную таблицу в памяти, вы должны
    закрепить ее в кэше. Это стоит делать только с малыми таблицами, которые
    находятся в постоянном использовании.
    Если вы обнаружили, что сервер выталкивает основные таблицы из
    памяти, вы можете закрепить их в памяти, используя параметр CACHE
    оператора CREATE/ALTER TABLE:
    ALTER TABLE [TABLENAME] CACHE;
    Table altered.
    Этот параметр гарантирует, что данные из таблицы после полного ее
    сканирования находятся в списке самых недавно использованных (most
    recently used - MRU) данных, а не в списке самых давно использованных (least
    recently used - LRU) данных, в результате чего они будут сохранены в памяти
    для последующего использования.
    
6. **Как изменить размеры пулов?**
    
    Через файл параметров или через alter system set.
    
    ![Untitled](LAB%206/Untitled.png)
    
    ![Untitled](LAB%206/Untitled%201.png)
    
    ![Untitled](LAB%206/Untitled%202.png)
    
    ![Untitled](LAB%206/Untitled%203.png)
    
    ![Untitled](LAB%206/Untitled%204.png)
    
    ![Untitled](LAB%206/Untitled%205.png)
    
7. **Какие пулы допускают изменение размеров?**
    
    KEEP, RECYCLE, DEFAULT, SHARED, LARGE, JAVA, LOG BUFFER.
    Нельзя изменить размер фиксированной области SGA (это по сути не является пулом, но помнить об этом надо).
    Размер самого SGA также можно изменить через alter system set sga_target = <int>m;
    
    ***ИЛИ***
    
    Oracle может автоматически управлять следующими пятью компонентами SGA (соответствующие инициализационные параметры Oracle указаны в скобках):
    
    - буферный кэш базы данных (*DB_CACHE_SIZE*);
    - разделяемый пул (*SHARED_POOL_SIZE*);
    - большой пул (*LARGE_POOL_SIZE*);
    - пул Java (*JAVA_POOL_SIZE*);
    - пул потоков (*STREAMS_POOL_SIZE*).
    
    Как видите, Oracle автоматически настраивает пять компонентов SGA, которые мы называем параметрами SGA с автоматически устанавливаемым размером. Вы должны по-прежнему самостоятельно управлять остальными компонентами SGA, даже при автоматическом управлении памятью.